"DET_Alt2_ResSim.xlsx")
)
#simple_run <- fbwR::runFBW(
simple_run <- runFBW(
template_file = file.path(data_path, "inputs",
"fbwR_template_Chinook-Fry_DET_Alt2b.xlsx"),
ressim_file = file.path(data_path, "inputs",
"DET_Alt2_ResSim.xlsx")
)
attributes(simple_run)
source("~/GitHub/fbwR/R/summarizeFBW.r")
#simple_summarized <- fbwR::summarizeFBW(
simple_summarized <- summarizeFBW(
simple_run, param_list = det_chk_params)
library(dplyr)
#simple_summarized <- fbwR::summarizeFBW(
simple_summarized <- summarizeFBW(
simple_run, param_list = det_chk_params)
source("~/GitHub/fbwR/R/summarizeFBW.r")
#simple_summarized <- fbwR::summarizeFBW(
simple_summarized <- summarizeFBW(
simple_run, param_list = det_chk_params)
attributes(simple_summarized)
names(simple_summarized)
simple_summarized[['toSLAM']]
fbw_df <- data.frame(
# All 1's to show as an example
fish_in_dam = rep(1, 12))
fbw_df
text_input <- "random[rnorm(mean = 0, sd = 1)]"
text_input
text_input <- gsub(x = text_input, pattern = "random[", replace = "", fixed = T)
text_input <- gsub(x = text_input, pattern = "]", replace = "", fixed = T)
text_input
text_input <- gsub(x = text_input, pattern = "random[", replace = "", fixed = T)
text_input
text_input <- gsub(x = text_input, pattern = "]", replace = "", fixed = T)
text_input
text_input <- gsub(x = text_input, pattern = "]", replace = "", fixed = T)
text_input
### This returns an error; we do not have n =  ... in the call yet
eval(parse(text = text_input)) # Error: argument "n" is missing
text_final <- gsub(text_input, pattern = ")",
# the replacement text can created using `paste0()` and `nrow()`
replace = paste0(", n = ", nrow(fbw_df), ")"),
fixed = TRUE)
text_final # "rnorm(mean = 0, sd = 1, n = 12)"
fbw_df
nrow(fbw_df)
text_final <- gsub(text_input, pattern = ")",
# the replacement text can created using `paste0()` and `nrow()`
replace = paste0(", n = ", nrow(fbw_df), ")"),
fixed = TRUE)
text_final # "rnorm(mean = 0, sd = 1, n = 12)"
### Step 4: Check that it works and add it to the fbw_df
survival_rates <- eval(parse(text = text_final))
survival_rates
library(dplyr)
fbw_df <- fbw_df %>%
mutate(
### add the survival rate as a column
survival_rate = survival_rates,
### multiply by the fish abundance in the dam
surviving = fish_in_dam * survival_rate)
fbw_df
fish_in_dam
survival_rate
survival_rates
surviving
fbw_df
fbw_df
fbw_df <- fbw_df %>%
mutate(
### add the survival rate as a column
survival_rate = survival_rates,
### multiply by the fish abundance in the dam
surviving = fish_in_dam * survival_rate)
fbw_df
fbw_df <- data.frame(
# All 1's to show as an example
fish_in_dam = rep(1, 12))
text_input <- "random[rnorm(mean = 0, sd = 1)]"
text_input <- gsub(x = text_input, pattern = "random[", replace = "", fixed = T)
text_input <- gsub(x = text_input, pattern = "]", replace = "", fixed = T)
### This returns an error; we do not have n =  ... in the call yet
eval(parse(text = text_input)) # Error: argument "n" is missing
text_final <- gsub(text_input, pattern = ")",
# the replacement text can created using `paste0()` and `nrow()`
replace = paste0(", n = ", nrow(fbw_df), ")"),
fixed = TRUE)
text_final <- gsub(text_input, pattern = ")",
# the replacement text can created using `paste0()` and `nrow()`
replace = paste0(", n = ", nrow(fbw_df), ")"),
fixed = TRUE)
text_final # "rnorm(mean = 0, sd = 1, n = 12)"
survival_rates <- eval(parse(text = text_final))
library(dplyr)
fbw_df <- fbw_df %>%
mutate(
### add the survival rate as a column
survival_rate = survival_rates,
### multiply by the fish abundance in the dam
surviving = fish_in_dam * survival_rate)
data.1  <- fbw_df
data.1
sims  <- c(0:4)
n       <- length(sims)
fbw_df
data.1  <- fbw_df
sims  <- c(0:4)
nsim       <- length(sims)
return_list <- list(rep(fbw_df, nsim))
return_list
for(i in 1:length(sims)){
data.1$fish_in_dam       <- fbw_df$fish_in_dam*2
data.1$survival_rate     <- fbw_df$fish_in_dam*0.5
writeData(paste('fbw_df','s',i,'.csv',sep=''), data.1, append=F)}
#!# return_list <- list(rep(ressim, nsim))
library(stringr)
for(i in 1:length(sims)){
data.1$fish_in_dam       <- fbw_df$fish_in_dam*2
data.1$survival_rate     <- fbw_df$fish_in_dam*0.5
writeData(paste('fbw_df','s',i,'.csv',sep=''), data.1, append=F)}
library(dplyr)
for(i in 1:length(sims)){
data.1$fish_in_dam       <- fbw_df$fish_in_dam*2
data.1$survival_rate     <- fbw_df$fish_in_dam*0.5
writeData(paste('fbw_df','s',i,'.csv',sep=''), data.1, append=F)}
library(reshape)
data.1  <- fbw_df
sims  <- c(0:4)
nsim       <- length(sims)
for(i in 1:length(sims)){
data.1$fish_in_dam       <- fbw_df$fish_in_dam*2
data.1$survival_rate     <- fbw_df$fish_in_dam*0.5
writeData(paste('fbw_df','s',i,'.csv',sep=''), data.1, append=F)}
for(i in 1:length(sims)){
data.1$fish_in_dam       <- fbw_df$fish_in_dam*2
data.1$survival_rate     <- fbw_df$fish_in_dam*0.5
}
data.1
for(i in 1:length(sims)){
data.1$fish_in_dam       <- fbw_df$fish_in_dam[i]*2 # just adding some variation to next data frames
data.1$survival_rate     <- fbw_df$fish_in_dam[i]*0.5 # just adding some variation to next data frames
}
data.1
for(i in 1:length(sims)){
data.1$fish_in_dam       <- fbw_df$fish_in_dam[i]*2 # just adding some variation to next data frames
data.1$survival_rate     <- fbw_df$fish_in_dam[i]*0.5 # just adding some variation to next data frames
return_list           <- list(data.1[i])
}
data.1
for (i in 1:10) {
if (!i %% 2){
next
}
print(i)
}
for (year in 2010:2015){
print(paste("The year is", year))
}
k <- data.frame(c(1:10),c(11:20),c(21:30))
k
names(k) <-  c('a','b','c')
k
length(k$a)
for(i in 1:length(k$a)) {
k$d <-  k[i,b]*2
}
for(i in 1:length(k$a)) {
k$d <-  k[i,k$b]*2
}
k
################################################################################
# Creating basic loops
################################################################################
# very basic loops
a <- 1:10                         #create a vector
b <- 1:10                         #create a vector
res<-rep(NA,length(a))            # this is an empty vector to save the loops result
for (i in 1:length(a)) {
res[i] <- a[i] + b[i]
}
res
# Nested "for Loops"
e=c(2,3,4,5)
f=c(3,4,5,6)
mat1=matrix(NA,nrow = length(e), ncol = length(f))# create an empty 4 x 4 matrix to save the outputs
mat1
for (i in 1:length(e)){
for (j in 1:length(f)){
mat1[i,j]<-(e[i]*f[j])
}
}
mat1 # matrix is filled
# Loop for Kat
k <- data.frame(c(1:10),c(11:20),c(21:30))
names(k) <-  c('a','b','c')
k
# option 1
kat <- matrix(NA,nrow = length(k$e), ncol = length(7)) # c7 columns bc you told me they are 7
kat
# option 1
kat <- matrix(NA,nrow = length(k$c), ncol = length(7)) # c7 columns bc you told me they are 7
kat
length(k$c)
# option 1
kat <- matrix(NA,nrow = length(k$c), ncol = 7) # c7 columns bc you told me they are 7
kat
for (i in 1:length(k$c))
{
kat[i,]<-(k[i,]*2)
}
length(k$c)
kat
for (i in 1:length(7))
{
kat[i,]<-(k[i,]*2)
}
for (i in 1:7) #length(k$c))
{
kat[i,]<-(k[i,]*2)
}
k[i,]
k[i,]*2
for (i in 1:7) #length(k$c))
{
kat[i]<-(k[i,]*2)
}
kat
# option 1
kat <- matrix(NA,nrow = length(k$c), ncol = 7) # 7 columns bc you told me they are 7
# option 1
kat <- matrix(NA,nrow = length(k$c), ncol = 7) # 7 columns bc you told me they are 7
kat
# option 1
kat <- matrix(NA,nrow = length(k$c), ncol = 3) # 7 columns bc you told me they are 7
for (i in 1:length(k$c))
{
kat[i,]<-(k[i,]*2)
}
# option 1
kat <- matrix(NA,nrow = length(k$c), ncol = 3) # 7 columns bc you told me they are 7
kat
k
k[i,]
kat[i,]
# option 1
kat <- matrix(NA,nrow = length(k$c), ncol = 3) # 7 columns bc you told me they are 7
for (i in 1:length(k$c))
{
kat[i,]<-(k[i,]*2)
}
kat
(k[i,]*2)
kat<-(k[i,]*2)
for (i in 1:length(k$c))
{
kat<-(k[i,]*2)
}
kat
# option 1
kat <- matrix(NA,nrow = length(k$c), ncol = 3) # 7 columns bc you told me they are 7
for (i in 1:length(k$c))
{
kat<-(k[i,]*2)
}
kat
# option 1
kat <- matrix(NA,nrow = length(k$c), ncol = 3) # 7 columns bc you told me they are 7
for (i in 1:length(k$c)){
kat[i,j]<-(k[i,]*2)
}
kat
for (i in 1:length(k$c)){
kat[]<-(k[i,]*2)
}
kat
mat2 = matrix(NA, nrow=10, ncol=10) # create an empty 10 x 10 matrix to save the outputs
mat2
for(i in 1:nrow(mat2))  # for each row
{
for(j in 1:ncol(mat2)) # for each column
{
mat2[i,j] = i*j     # assign values based on position: product of two indexes
}
}
mat2
k
length(k$a)
mat2 = matrix(NA, nrow=length(k$a), ncol=7) # create an empty 10 x 10 matrix to save the outputs
for(i in 1:nrow(mat2))  # for each row
{
for(j in 1:ncol(mat2)) # for each column
{
mat2[i,j] = i*j     # assign values based on position: product of two indexes
}
}
mat2
k$a[i]
k$a
k
k$a[j]
for(i in 1:nrow(mat2))  # for each row
{
for(j in 1:ncol(mat2)) # for each column
{
mat2[i,j] = k$a[i]*k$a[j]     # assign values based on position: product of two indexes
}
}
mat2
rm(mat2)
mat2
mat2 = matrix(NA, nrow=length(k$a), ncol=7) # create an empty 10 x 10 matrix to save the outputs
mat2
for(i in 1:nrow(mat2))  # for each row
{
for(j in 1:ncol(mat2)) # for each column
{
mat2[i,j] = k$a[i]*k$a[j]     # assign values based on position: product of two indexes
}
}
mat2
wmm::GetMagneticFieldWMM(
lon = 240,
lat = -80,
height = 1e5,
time = 2022.5
)
for (i in 2010:2015){
print(paste("The year is", i))
}
# Loop for Kat
k <- data.frame(c(1:10),c(11:20),c(21:30), c(31:40))
names(k) <-  c('a','b','c','d')
k
1:length(k$a)
k
kat <- data.frame(NA,nrow = length(k$c), ncol = 3) # 7 columns bc you told me they are 7
kat
# option 1
kat <- matrix(NA,nrow = length(k$c), ncol = 3) # 7 columns bc you told me they are 7
kat
# option 1
kat <- matrix(NA,nrow = length(k$c), ncol = 3) # 7 columns bc you told me they are 7
kat <- as.data.frame(kat)
kat
# option 1
kat <- matrix(NA,nrow = length(k$c), ncol = 13) # 13 columns bc you told me they are 7
kat <- as.data.frame(kat)
kat
tmp <- matrix(NA,nrow = length(k$c), ncol = 4) #
tmp <- as.data.frame(tmp)
tmp
for (i in 1:length(k$c)){
tmp<-(tmp[i,])
}
tmp
for (i in 1:length(k$c)){
tmp[,j]<-(k[i,])
}
for (i in 1:length(k$c)){
tmp[,j]<-(k[i,j])
}
k
#Exponential population declines under different Z. Fig. 3.6
yrs <- 50; yrs1 <- yrs + 1 # to leave room for B[0]
years <- seq(0,yrs,1)
B0 <- 1000 # now alternative total mortality rates
Z <- c(0.05,0.1,0.2,0.4,0.55)
nZ <- length(Z)
Bt <- matrix(0,nrow=yrs1,ncol=nZ,dimnames=list(years,Z))
Bt
Bt[1,] <- B0
Bt
for (j in 1:nZ)
for (i in 2:yrs1)
Bt[i,j] <- Bt[(i-1),j]*exp(-Z[j])
Bt
Bt
Bt <- matrix(0,nrow=yrs1,ncol=nZ,dimnames=list(years,Z))
Bt
k$a
#Z <- c(0.05,0.1,0.2,0.4,0.55)
nZ <- 13 #length(Z)
Bt <- matrix(0,nrow=k$a,ncol=nZ,dimnames=list(years,Z)) # nrow needs to be length of data frame of data
Bt <- matrix(0,nrow=k$a,ncol=nZ) # nrow needs to be length of data frame of data
Bt
k$a
Bt <- matrix(0,nrow=k$a,ncol=nZ) # nrow needs to be length of data frame of data
Bt
Bt[]
Bt[10,]
#Z <- c(0.05,0.1,0.2,0.4,0.55)
nZ <- 13 #length(Z)
k$a
Bt <- matrix(0,nrow=10,ncol=nZ) # nrow needs to be length of data frame of data
Bt
#Exponential population declines under different Z. Fig. 3.6
yrs <- 50; yrs1 <- yrs + 1 # to leave room for B[0]
years <- seq(0,yrs,1)
B0 <- 1000 # now alternative total mortality rates
Z <- c(0.05,0.1,0.2,0.4,0.55)
nZ <- length(Z)
Bt <- matrix(0,nrow=yrs1,ncol=nZ,dimnames=list(years,Z))
Bt
Bt[1,] <- B0
Bt
for (j in 1:nZ)
for (i in 2:yrs1)
Bt[i,j] <- Bt[(i-1),j]*exp(-Z[j])
Bt
#Exponential population declines under different Z. Fig. 3.6
yrs <- 15; yrs1 <- yrs + 1 # to leave room for B[0]
years <- seq(0,yrs,1)
B0 <- 1000 # now alternative total mortality rates
Z <- c(0.05,0.1,0.2,0.4,0.55)
nZ <- length(Z)
Bt <- matrix(0,nrow=yrs1,ncol=nZ,dimnames=list(years,Z))
Bt
Bt[1,] <- B0
Bt
for (j in 1:nZ)
for (i in 2:yrs1)
Bt[i,j] <- Bt[(i-1),j]*exp(-Z[j])
Bt
results <- matrix(0,nrow=10,ncol=nZ) # nrow needs to be length of data frame of data
resutls
#Z <- c(0.05,0.1,0.2,0.4,0.55)
nZ <- 13 #length(Z)
results <- matrix(0,nrow=10,ncol=nZ) # nrow needs to be length of data frame of data
resutls
results <- matrix(0,nrow=10,ncol=nZ) # nrow needs to be length of data frame of data
resutls
results
for (j in 1:nZ)
for (i in 1:10)
{
wmm::GetMagneticFieldWMM(
lon = k$a[i],
lat = k$b[i],
height = k$c[i],
time = k$d[i]
)
}
results
# Create an empty list to store the results
results <- list()
results
# Call the function with the current values
magnetic_field <- wmm::GetMagneticFieldWMM(lon = lon, lat = lat, height = height, time = time)
lst <- list('one','two','three')
lst
a <- lst[1]
class(a)
a <- lst[[1]]
class(a)
results <- matrix(0,nrow=10,ncol=nZ) # nrow needs to be length of data frame of data
results
# Create vectors of values for lon, lat, and time
lon_values <- c(240, 241, 242)  # Replace with your desired values
lat_values <- c(-80, -81, -82)  # Replace with your desired values
time_values <- c(2022.5, 2023.0, 2023.5)  # Replace with your desired values
lon_values
# Constant height
height <- 1e5
# Create an empty list to store the results
results <- list()
# Use a for loop to call the function with different values
for (i in 1:length(lon_values)) {
lon <- lon_values[i]
lat <- lat_values[i]
time <- time_values[i]
# Call the function with the current values
magnetic_field <- (lon = lon, lat = lat, height = height, time = time)
# Print the results
print(results)
results
fbw_df <- data.frame(
# All 1's to show as an example
fish_in_dam = rep(1, 12))
text_input <- "random[rnorm(mean = 0, sd = 1)]"
text_input <- gsub(x = text_input, pattern = "random[", replace = "", fixed = T)
text_input <- gsub(x = text_input, pattern = "]", replace = "", fixed = T)
text_final <- gsub(text_input, pattern = ")",
# the replacement text can created using `paste0()` and `nrow()`
replace = paste0(", n = ", nrow(fbw_df), ")"),
fixed = TRUE)
text_final # "rnorm(mean = 0, sd = 1, n = 12)"
survival_rates <- eval(parse(text = text_final))
survival_rates
library(dplyr)
fbw_df <- fbw_df %>%
mutate(
### add the survival rate as a column
survival_rate = survival_rates,
### multiply by the fish abundance in the dam
surviving = fish_in_dam * survival_rate)
fbw_df
data.1  <- fbw_df
data.1
sims  <- c(0:4)
nsim       <- length(sims)
nsim
for(i in 1:length(sims)){
data.1$fish_in_dam       <- fbw_df$fish_in_dam[i]*2 # just adding some variation to next data frames
data.1$survival_rate     <- fbw_df$fish_in_dam[i]*0.5 # just adding some variation to next data frames
return_list           <- list(data.1[i])
}
return_list
fbw_df
return_list
